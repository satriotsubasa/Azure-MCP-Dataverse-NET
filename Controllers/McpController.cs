using Microsoft.AspNetCore.Mvc;
using System.Text.Json;
using DataverseMcp.WebApi.Models;
using DataverseMcp.WebApi.Services;

namespace DataverseMcp.WebApi.Controllers;

[ApiController]
[Route("api/[controller]")]
public class McpController : ControllerBase
{
    private readonly ILogger<McpController> _logger;
    private readonly DataverseService? _dataverseService;

    public McpController(ILogger<McpController> logger, DataverseService? dataverseService = null)
    {
        _logger = logger;
        _dataverseService = dataverseService;
    }

    [HttpOptions]
    public IActionResult HandleOptions()
    {
        return Ok();
    }

    [HttpGet]
    public IActionResult GetServerInfo()
    {
        var serverInfo = new
        {
            name = "Dataverse MCP Server - .NET Web API",
            version = "1.0.0",
            description = "MCP server for ChatGPT integration with Microsoft Dataverse using .NET and SQL4CDS",
            protocol = "MCP/1.0",
            capabilities = new[] { "tools" },
            status = "healthy",
            authentication = "none",
            environment = "render",
            endpoints = new
            {
                mcp = "POST /api/mcp",
                health = "GET /api/health",
                diagnostic = "GET /api/diagnostic"
            }
        };

        return Ok(serverInfo);
    }

    [HttpPost]
    public async Task<IActionResult> HandleMcpRequest([FromBody] JsonElement body)
    {
        _logger.LogInformation("MCP Request received: {Method}", Request.Method);

        try
        {
            var requestBody = body.GetRawText();
            _logger.LogInformation("MCP Request body: {Body}", requestBody);

            if (string.IsNullOrEmpty(requestBody))
            {
                return Ok(CreateMcpErrorResponse(null, -32700, "Parse error"));
            }

            var mcpRequest = JsonSerializer.Deserialize<McpRequest>(requestBody, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });

            if (mcpRequest == null)
            {
                return Ok(CreateMcpErrorResponse(null, -32700, "Parse error"));
            }

            return await ProcessMcpMethod(mcpRequest);
        }
        catch (JsonException ex)
        {
            _logger.LogError(ex, "JSON parsing error");
            return Ok(CreateMcpErrorResponse(null, -32700, "Parse error"));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing MCP request");
            return Ok(CreateMcpErrorResponse(null, -32603, "Internal error"));
        }
    }

    private async Task<IActionResult> ProcessMcpMethod(McpRequest mcpRequest)
    {
        _logger.LogInformation("Processing MCP method: {Method}", mcpRequest.Method);

        return mcpRequest.Method switch
        {
            "initialize" => Ok(await HandleInitialize(mcpRequest.Id, mcpRequest)),
            "tools/list" => Ok(await HandleToolsList(mcpRequest.Id)),
            "tools/call" => Ok(await HandleToolsCall(mcpRequest.Id, mcpRequest.Params)),
            "notifications/initialized" => Ok(await HandleNotificationsInitialized(mcpRequest.Id)),
            _ => Ok(CreateMcpErrorResponse(mcpRequest.Id, -32601, $"Unknown method: {mcpRequest.Method}"))
        };
    }

    private async Task<McpResponse> HandleInitialize(object? requestId, McpRequest? mcpRequest = null)
    {
        await Task.Delay(1); // Make async

        // Use the protocol version from the client request, or default to latest
        var clientProtocolVersion = "2025-03-26"; // Default
        if (mcpRequest?.Params != null)
        {
            var paramsJson = JsonSerializer.Serialize(mcpRequest.Params);
            var initParams = JsonSerializer.Deserialize<JsonElement>(paramsJson);
            if (initParams.TryGetProperty("protocolVersion", out var versionElement))
            {
                clientProtocolVersion = versionElement.GetString() ?? "2025-03-26";
            }
        }

        var result = new McpInitializeResult
        {
            ProtocolVersion = clientProtocolVersion,
            Capabilities = new McpCapabilities
            {
                Tools = new { }
            },
            ServerInfo = new McpServerInfo
            {
                Name = "Dataverse MCP Server - .NET Web API",
                Version = "1.0.0"
            },
            Instructions = @"# System Context

You will be asked questions pertaining to Dataverse. The main objective is to retrieve data on transactional tables using SQL.

# System Rules

- Always end with the following line: _Generated by AI. Please verify for correctness._
- Before using any tools, always show the input that will be used.
- Always show formatted data like JSON or XML in a code block.
- Use `GetRowsForTable`, `GetMetadataForAllTables`, `ConvertFetchXmlToSql`, `ExecuteSQL`, `GetMetadataByTableName` and `GetFieldMetadataByTableName` tools if required.
- Always try to retrieve records which are in active state.
- Discover table metadata and validate using `GetFieldMetadataByTableName`.
- If `GetRowsForTable` or `ExecuteSQL` you must confirm the metadata for the tables atleast once using `GetFieldMetadataByTableName` without any field filters before proceeding.
- `GetRowsForTable` cannot be run before the metadata for the table is confirmed. Metadata confirmation is required only once.
- Use SQL for querying. None of the tables need to have Filtered as a prefix.
- When ordering results, use highest to lowest for aggregated queries, and most recent to oldest by modifiedon for other queries.
- The tool call response is in JSON and can be found inside <json_output> element. You muse parse it and use it.
- Always user lowercase for entity/table names and field names, when you pass them are parameters to tools, as the collation is case sensitive.
- Avoid repeated calls to get metadata for entity/table with exact same field multiple times in the same session.
- Always end with the following line: _Generated by AI. Please verify for correctness._
- Always show structured data like JSON or XML inside code blocks or script in the code block.
- If field is a Picklist/Optionset/Choices/Choice or EntityReference/Lookup do not use it in query directly. Instead used the logical virtual field related to it. e.g. use createdbyname instead of createdby, isdisabledname instead of isdisabled etc, as these are more readable. If those fields do not exist, use the actual field.
- Always use schema name in the SQL queries. Schema can be either ""dbo"", or ""metadata"".
- For each table, and for each row in that table, also generate a hyperlink in the following format [ENVIRONMENT]/main.aspx?etn=[TABLE_NAME]&pagetype=entityrecord&id=[RECORD_ID]. The readable name for the hyperlink in the Markdown should be the primarynameattribute of that table.
- CURRENT_USER, USER_NAME(), or equserid() can be used to get current userid. The all return a GUID.

# Security Guidelines

- Do not show any sensitive information like Secret, Client/Application Id, Password, or Tenant Id in the output.
- Restrict all SQL queries to use only SELECT statements. Any queries that try to UPDATE, INSERT or DELETE should automatically be rejected.

Enterprise .NET Web API MCP server for Microsoft Dataverse using SQL4CDS. Focus on legalops_matters table for legal matters search and retrieval."
        };

        return new McpResponse
        {
            Id = requestId,
            Result = result
        };
    }

    private async Task<McpResponse> HandleNotificationsInitialized(object? requestId)
    {
        await Task.Delay(1); // Make async
        
        // Notifications/initialized should return null result according to MCP spec
        return new McpResponse
        {
            Id = requestId,
            Result = null
        };
    }

    private async Task<McpResponse> HandleToolsList(object? requestId)
    {
        await Task.Delay(1); // Make async

        var tools = new McpTool[]
        {
            new()
            {
                Name = "search",
                Description = "Search for legal matters in Dataverse. Returns IDs of matching matters.",
                InputSchema = new McpInputSchema
                {
                    Type = "object",
                    Properties = new Dictionary<string, McpProperty>
                    {
                        ["query"] = new McpProperty
                        {
                            Type = "string",
                            Description = "Search query to find legal matters"
                        },
                        ["limit"] = new McpProperty
                        {
                            Type = "number",
                            Description = "Maximum number of results to return (default 10)"
                        }
                    },
                    Required = new[] { "query" }
                }
            },
            new()
            {
                Name = "fetch",
                Description = "Fetch a specific matter by ID. Takes an ID and returns the record.",
                InputSchema = new McpInputSchema
                {
                    Type = "object",
                    Properties = new Dictionary<string, McpProperty>
                    {
                        ["id"] = new McpProperty
                        {
                            Type = "string",
                            Description = "The ID of the matter to fetch"
                        }
                    },
                    Required = new[] { "id" }
                }
            },
            new()
            {
                Name = "ExecuteSQL",
                Description = "Executes an SQL query against Dataverse. Must be only SELECT statements.",
                InputSchema = new McpInputSchema
                {
                    Type = "object",
                    Properties = new Dictionary<string, McpProperty>
                    {
                        ["sqlQuery"] = new McpProperty
                        {
                            Type = "string",
                            Description = "The SQL query to execute. Must be only SELECT."
                        }
                    },
                    Required = new[] { "sqlQuery" }
                }
            },
            new()
            {
                Name = "GetMetadataForAllTables",
                Description = "Get metadata for all tables in Dataverse.",
                InputSchema = new McpInputSchema
                {
                    Type = "object",
                    Properties = new Dictionary<string, McpProperty>
                    {
                        ["metadataFieldNames"] = new McpProperty
                        {
                            Type = "array",
                            Description = "The metadata columns to retrieve e.g. [\"metadataid\", \"logicalname\"]"
                        },
                        ["conditions"] = new McpProperty
                        {
                            Type = "string",
                            Description = "Condition to filter down the table metadata e.g. isactivity = 1 AND islogicalentity = 1"
                        }
                    },
                    Required = new[] { "metadataFieldNames" }
                }
            },
            new()
            {
                Name = "GetMetadataByTableName",
                Description = "Get metadata for a specific table.",
                InputSchema = new McpInputSchema
                {
                    Type = "object",
                    Properties = new Dictionary<string, McpProperty>
                    {
                        ["tableName"] = new McpProperty
                        {
                            Type = "string",
                            Description = "The table's logical name e.g. contact, account"
                        },
                        ["metadataFieldNames"] = new McpProperty
                        {
                            Type = "array",
                            Description = "The metadata columns to retrieve e.g. [\"metadataid\", \"logicalname\"]"
                        }
                    },
                    Required = new[] { "tableName", "metadataFieldNames" }
                }
            },
            new()
            {
                Name = "GetFieldMetadataByTableName",
                Description = "Get metadata for fields in a specific table.",
                InputSchema = new McpInputSchema
                {
                    Type = "object",
                    Properties = new Dictionary<string, McpProperty>
                    {
                        ["tableName"] = new McpProperty
                        {
                            Type = "string",
                            Description = "The table's logical name e.g. contact, account"
                        },
                        ["metadataFieldNames"] = new McpProperty
                        {
                            Type = "array",
                            Description = "The metadata columns to retrieve e.g. [\"metadataid\", \"isvalidforread\"]"
                        },
                        ["conditions"] = new McpProperty
                        {
                            Type = "string",
                            Description = "Condition to filter down the attribute metadata e.g. isfilterable = 1 AND isvalidforupdate = 1"
                        }
                    },
                    Required = new[] { "tableName", "metadataFieldNames" }
                }
            },
            new()
            {
                Name = "GetRowsForTable",
                Description = "Retrieve rows for a specific table.",
                InputSchema = new McpInputSchema
                {
                    Type = "object",
                    Properties = new Dictionary<string, McpProperty>
                    {
                        ["tableName"] = new McpProperty
                        {
                            Type = "string",
                            Description = "The table's logical name e.g. contact, account"
                        },
                        ["fieldNames"] = new McpProperty
                        {
                            Type = "array",
                            Description = "The field names to retrieve from the table e.g. [\"contactid\", \"fullname\"]"
                        },
                        ["conditions"] = new McpProperty
                        {
                            Type = "string",
                            Description = "Condition to filter down the table"
                        },
                        ["sortOrder"] = new McpProperty
                        {
                            Type = "string",
                            Description = "The sort order for the results e.g. fullname DESC."
                        },
                        ["rowCount"] = new McpProperty
                        {
                            Type = "number",
                            Description = "The number of rows to retrieve. Defaults to 50."
                        }
                    },
                    Required = new[] { "tableName", "fieldNames" }
                }
            },
            new()
            {
                Name = "ConvertFetchXmlToSql",
                Description = "Convert FetchXml query to SQL query.",
                InputSchema = new McpInputSchema
                {
                    Type = "object",
                    Properties = new Dictionary<string, McpProperty>
                    {
                        ["fetchXml"] = new McpProperty
                        {
                            Type = "string",
                            Description = "FetchXml query"
                        }
                    },
                    Required = new[] { "fetchXml" }
                }
            }
        };

        var result = new McpToolsListResult { Tools = tools };
        return new McpResponse
        {
            Id = requestId,
            Result = result
        };
    }

    private async Task<McpResponse> HandleToolsCall(object? requestId, object? parameters)
    {
        try
        {
            if (parameters == null)
            {
                return CreateMcpErrorResponse(requestId, -32602, "Invalid params");
            }

            var paramsJson = JsonSerializer.Serialize(parameters);
            var toolParams = JsonSerializer.Deserialize<McpToolCallParams>(paramsJson);

            if (toolParams == null)
            {
                return CreateMcpErrorResponse(requestId, -32602, "Invalid params");
            }

            _logger.LogInformation("Tool call: {ToolName} with args: {Args}", toolParams.Name, 
                JsonSerializer.Serialize(toolParams.Arguments));

            return toolParams.Name switch
            {
                "search" => await HandleSearchTool(requestId, toolParams.Arguments),
                "fetch" => await HandleFetchTool(requestId, toolParams.Arguments),
                "ExecuteSQL" => await HandleExecuteSqlTool(requestId, toolParams.Arguments),
                "GetMetadataForAllTables" => await HandleGetMetadataForAllTablesTool(requestId, toolParams.Arguments),
                "GetMetadataByTableName" => await HandleGetMetadataByTableNameTool(requestId, toolParams.Arguments),
                "GetFieldMetadataByTableName" => await HandleGetFieldMetadataByTableNameTool(requestId, toolParams.Arguments),
                "GetRowsForTable" => await HandleGetRowsForTableTool(requestId, toolParams.Arguments),
                "ConvertFetchXmlToSql" => await HandleConvertFetchXmlToSqlTool(requestId, toolParams.Arguments),
                _ => CreateMcpErrorResponse(requestId, -32601, $"Unknown tool: {toolParams.Name}")
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in tools/call");
            return CreateMcpErrorResponse(requestId, -32603, "Tool execution failed");
        }
    }

    private async Task<McpResponse> HandleSearchTool(object? requestId, Dictionary<string, object> arguments)
    {
        try
        {
            if (_dataverseService == null)
            {
                return CreateMcpErrorResponse(requestId, -32603, "DataverseService not available - check connection configuration");
            }

            var query = ExtractStringParameter(arguments, "query");
            var limit = ExtractIntParameter(arguments, "limit") ?? 10;

            if (string.IsNullOrEmpty(query))
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'query' parameter");
            }

            _logger.LogInformation("Searching for matters with query: {Query}, limit: {Limit}", query, limit);

            var searchResults = await _dataverseService.SearchMattersAsync(query, limit);

            // Convert to the format ChatGPT expects - return IDs and metadata
            var results = searchResults.Select(r => new
            {
                id = r.Id,
                title = r.Title,
                text = r.Text,
                url = r.Url,
                metadata = r.Metadata
            }).ToArray();

            // Return content array format for MCP tool calls
            var content = new[]
            {
                new
                {
                    type = "text",
                    text = results.Length > 0 
                        ? $"Found {results.Length} legal matter(s):\n\n" + 
                          string.Join("\n", results.Select((r, i) => 
                              $"{i + 1}. **{r.title}** (ID: {r.id})\n   {r.text}\n   Code: {r.metadata["code"]}"))
                        : "No matters matched your search query."
                }
            };

            return new McpResponse
            {
                Id = requestId,
                Result = new
                {
                    content = content
                }
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Search tool failed");
            return CreateMcpErrorResponse(requestId, -32603, $"Search failed: {ex.Message}");
        }
    }

    private async Task<McpResponse> HandleFetchTool(object? requestId, Dictionary<string, object> arguments)
    {
        try
        {
            if (_dataverseService == null)
            {
                return CreateMcpErrorResponse(requestId, -32603, "DataverseService not available - check connection configuration");
            }

            var id = ExtractStringParameter(arguments, "id");

            if (string.IsNullOrEmpty(id))
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'id' parameter");
            }

            _logger.LogInformation("Fetching matter with ID: {Id}", id);

            var result = await _dataverseService.FetchRecordAsync(id, "matters");

            if (result == null)
            {
                return CreateMcpErrorResponse(requestId, -32603, $"Record with ID {id} not found");
            }

            // Return content array format for MCP tool calls
            var content = new[]
            {
                new
                {
                    type = "text",
                    text = $"**{result.Title}** (ID: {result.Id})\n\n" +
                           $"Description: {result.Text}\n" +
                           $"Code: {result.Metadata.GetValueOrDefault("code", "")}\n" +
                           $"Name: {result.Metadata.GetValueOrDefault("name", "")}\n" +
                           $"URL: {result.Url}"
                }
            };

            return new McpResponse
            {
                Id = requestId,
                Result = new
                {
                    content = content
                }
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Fetch tool failed");
            return CreateMcpErrorResponse(requestId, -32603, $"Fetch failed: {ex.Message}");
        }
    }

    private async Task<McpResponse> HandleExecuteSqlTool(object? requestId, Dictionary<string, object> arguments)
    {
        try
        {
            if (_dataverseService == null)
            {
                return CreateMcpErrorResponse(requestId, -32603, "DataverseService not available - check connection configuration");
            }

            var sqlQuery = ExtractStringParameter(arguments, "sqlQuery");
            if (string.IsNullOrEmpty(sqlQuery))
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'sqlQuery' parameter");
            }

            _logger.LogInformation("Executing SQL: {SqlQuery}", sqlQuery);

            var result = await _dataverseService.ExecuteSqlQueryAsync(sqlQuery);
            return new McpResponse
            {
                Id = requestId,
                Result = result
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ExecuteSQL tool failed");
            return CreateMcpErrorResponse(requestId, -32603, $"ExecuteSQL failed: {ex.Message}");
        }
    }

    private async Task<McpResponse> HandleGetMetadataForAllTablesTool(object? requestId, Dictionary<string, object> arguments)
    {
        try
        {
            if (_dataverseService == null)
            {
                return CreateMcpErrorResponse(requestId, -32603, "DataverseService not available - check connection configuration");
            }

            var metadataFieldNames = ExtractStringArrayParameter(arguments, "metadataFieldNames");
            var conditions = ExtractStringParameter(arguments, "conditions");

            if (metadataFieldNames == null || metadataFieldNames.Length == 0)
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'metadataFieldNames' parameter");
            }

            _logger.LogInformation("Getting metadata for all tables with fields: {Fields}", string.Join(",", metadataFieldNames));

            var result = await _dataverseService.GetMetadataForAllTablesAsync(metadataFieldNames, conditions);
            return new McpResponse
            {
                Id = requestId,
                Result = result
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "GetMetadataForAllTables tool failed");
            return CreateMcpErrorResponse(requestId, -32603, $"GetMetadataForAllTables failed: {ex.Message}");
        }
    }

    private async Task<McpResponse> HandleGetMetadataByTableNameTool(object? requestId, Dictionary<string, object> arguments)
    {
        try
        {
            if (_dataverseService == null)
            {
                return CreateMcpErrorResponse(requestId, -32603, "DataverseService not available - check connection configuration");
            }

            var tableName = ExtractStringParameter(arguments, "tableName");
            var metadataFieldNames = ExtractStringArrayParameter(arguments, "metadataFieldNames");

            if (string.IsNullOrEmpty(tableName))
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'tableName' parameter");
            }

            if (metadataFieldNames == null || metadataFieldNames.Length == 0)
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'metadataFieldNames' parameter");
            }

            _logger.LogInformation("Getting metadata for table: {TableName}", tableName);

            var result = await _dataverseService.GetMetadataByTableNameAsync(tableName, metadataFieldNames);
            return new McpResponse
            {
                Id = requestId,
                Result = result
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "GetMetadataByTableName tool failed");
            return CreateMcpErrorResponse(requestId, -32603, $"GetMetadataByTableName failed: {ex.Message}");
        }
    }

    private async Task<McpResponse> HandleGetFieldMetadataByTableNameTool(object? requestId, Dictionary<string, object> arguments)
    {
        try
        {
            if (_dataverseService == null)
            {
                return CreateMcpErrorResponse(requestId, -32603, "DataverseService not available - check connection configuration");
            }

            var tableName = ExtractStringParameter(arguments, "tableName");
            var metadataFieldNames = ExtractStringArrayParameter(arguments, "metadataFieldNames");
            var conditions = ExtractStringParameter(arguments, "conditions");

            if (string.IsNullOrEmpty(tableName))
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'tableName' parameter");
            }

            if (metadataFieldNames == null || metadataFieldNames.Length == 0)
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'metadataFieldNames' parameter");
            }

            _logger.LogInformation("Getting field metadata for table: {TableName}", tableName);

            var result = await _dataverseService.GetFieldMetadataByTableNameAsync(tableName, metadataFieldNames, conditions);
            return new McpResponse
            {
                Id = requestId,
                Result = result
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "GetFieldMetadataByTableName tool failed");
            return CreateMcpErrorResponse(requestId, -32603, $"GetFieldMetadataByTableName failed: {ex.Message}");
        }
    }

    private async Task<McpResponse> HandleGetRowsForTableTool(object? requestId, Dictionary<string, object> arguments)
    {
        try
        {
            if (_dataverseService == null)
            {
                return CreateMcpErrorResponse(requestId, -32603, "DataverseService not available - check connection configuration");
            }

            var tableName = ExtractStringParameter(arguments, "tableName");
            var fieldNames = ExtractStringArrayParameter(arguments, "fieldNames");
            var conditions = ExtractStringParameter(arguments, "conditions");
            var sortOrder = ExtractStringParameter(arguments, "sortOrder");
            var rowCount = ExtractIntParameter(arguments, "rowCount") ?? 50;

            if (string.IsNullOrEmpty(tableName))
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'tableName' parameter");
            }

            if (fieldNames == null || fieldNames.Length == 0)
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'fieldNames' parameter");
            }

            _logger.LogInformation("Getting rows for table: {TableName}", tableName);

            var result = await _dataverseService.GetRowsForTableAsync(tableName, fieldNames, conditions, sortOrder, rowCount);
            return new McpResponse
            {
                Id = requestId,
                Result = result
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "GetRowsForTable tool failed");
            return CreateMcpErrorResponse(requestId, -32603, $"GetRowsForTable failed: {ex.Message}");
        }
    }

    private async Task<McpResponse> HandleConvertFetchXmlToSqlTool(object? requestId, Dictionary<string, object> arguments)
    {
        try
        {
            if (_dataverseService == null)
            {
                return CreateMcpErrorResponse(requestId, -32603, "DataverseService not available - check connection configuration");
            }

            var fetchXml = ExtractStringParameter(arguments, "fetchXml");
            if (string.IsNullOrEmpty(fetchXml))
            {
                return CreateMcpErrorResponse(requestId, -32602, "Missing or invalid 'fetchXml' parameter");
            }

            _logger.LogInformation("Converting FetchXML to SQL");

            var result = await _dataverseService.ConvertFetchXmlToSqlAsync(fetchXml);
            return new McpResponse
            {
                Id = requestId,
                Result = result
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ConvertFetchXmlToSql tool failed");
            return CreateMcpErrorResponse(requestId, -32603, $"ConvertFetchXmlToSql failed: {ex.Message}");
        }
    }

    // Helper methods to extract parameters from arguments
    private string? ExtractStringParameter(Dictionary<string, object> arguments, string parameterName)
    {
        if (!arguments.TryGetValue(parameterName, out var value))
            return null;

        if (value is string stringValue)
            return stringValue;

        if (value is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.String)
            return jsonElement.GetString();

        return null;
    }

    private string[]? ExtractStringArrayParameter(Dictionary<string, object> arguments, string parameterName)
    {
        if (!arguments.TryGetValue(parameterName, out var value))
            return null;

        if (value is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)
        {
            var stringList = new List<string>();
            foreach (var element in jsonElement.EnumerateArray())
            {
                if (element.ValueKind == JsonValueKind.String)
                {
                    var stringValue = element.GetString();
                    if (!string.IsNullOrEmpty(stringValue))
                        stringList.Add(stringValue);
                }
            }
            return stringList.ToArray();
        }

        return null;
    }

    private int? ExtractIntParameter(Dictionary<string, object> arguments, string parameterName)
    {
        if (!arguments.TryGetValue(parameterName, out var value))
            return null;

        if (value is int intValue)
            return intValue;

        if (value is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Number)
            return jsonElement.GetInt32();

        return null;
    }

    private static McpResponse CreateMcpErrorResponse(object? requestId, int code, string message)
    {
        return new McpResponse
        {
            Id = requestId,
            Error = new McpError
            {
                Code = code,
                Message = message
            }
        };
    }
}